<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>sublimeText插件</title>
    <link href="/2016/08/25/sublimeText%E6%8F%92%E4%BB%B6/"/>
    <url>/2016/08/25/sublimeText%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<ul><li><p><strong><a href="https://github.com/wbond/package_control">Package Control</a></strong> 插件管理</p></li><li><p>cmd+shift+p 唤醒</p></li><li><p><strong>Alignment</strong> 等号对齐</p></li><li><p>Ctrl+Alt+A</p></li><li><p><strong>Emmet</strong> 快速编写HTML和CSS代码</p></li><li><p><strong>FileDiffs</strong> 对比文本</p></li><li><p><strong>Git</strong></p></li><li><p><strong><a href="https://github.com/revolunet/sublimetext-markdown-preview">Markdown Preview</a></strong> 浏览器浏览markdown效果</p></li><li><p><strong><a href="https://github.com/tanepiper/SublimeText-Nodejs">Nodejs</a></strong> Nodejs开发专用！代码提示</p></li><li><p>Run current script in node (Ctrl + R)</p></li><li><p>Run current script in node debug (Ctrl + D)</p></li><li><p>Run current script in node and arguments (Ctrl + Alt + r)</p></li><li><p>Run current script in node debug and arguments (Ctrl + Alt + D)</p></li><li><p><strong><a href="https://github.com/dzhibas/SublimePrettyJson">Pretty Json</a></strong> JSON格式化</p></li><li><p>The default key binding is “ctrl+alt+f”</p></li><li><p>Open the command palette via “ctrl + shift + p”, Jsformat appears as “Format: Javascript”</p></li><li><p><strong><a href="https://github.com/jdc0589/JsFormat">JsFormat</a></strong> Js格式化</p></li><li><p><strong><a href="https://github.com/uipoet/sublime-jshint">JSHint</a></strong> Js语法检测</p></li><li><p>control-j or alt-j in Linux&#x2F;Windows or Tools&#x2F;Contextual menus or the Command Palette</p></li><li><p>F4 jump to next error row&#x2F;column</p></li><li><p>shift-F4 jump to previous error row-column</p></li><li><p><strong><a href="https://github.com/Benvie/JavaScriptNext.tmLanguage">JavaScriptNext</a></strong> Js语法插件</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>plugin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>plugin</tag>
      
      <tag>sublimeText</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>blog相关</title>
    <link href="/2016/03/29/blog%E7%9B%B8%E5%85%B3/"/>
    <url>/2016/03/29/blog%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="markdown教程"><a href="#markdown教程" class="headerlink" title="markdown教程"></a><a href="http://sspai.com/25137">markdown教程</a></h2><ul><li><a href="https://maxiang.io/">马克飞象</a></li></ul><h2 id="jekyll"><a href="#jekyll" class="headerlink" title="jekyll"></a><a href="https://github.com/jekyll/jekyll">jekyll</a></h2><blockquote><p>jekyll是基于Github搭建个人博客，源生支持方式</p></blockquote><ul><li><p><a href="http://jekyll.bootcss.com/">jekyll教程</a></p></li><li><p><a href="https://github.com/plusjade/jekyll-bootstrap">jekyll-bootstrap</a></p></li><li><p><a href="https://github.com/imathis/octopress">octopress</a></p></li><li><p><a href="https://github.com/jekyll/jekyll/wiki/Sites">jekyll官方推荐主题</a></p></li><li><p><a href="http://jekyllthemes.org/">jekyll更多主题</a></p></li></ul><h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a><a href="https://github.com/hexojs/hexo">hexo</a></h2><blockquote><p>hexo，比jekyll更快！</p></blockquote><ul><li><p><a href="https://hexo.io/zh-cn/">hexo官网(教程)</a></p></li><li><p><a href="http://ibruce.info/2013/11/22/hexo-your-blog/">hexo你的博客</a></p></li><li><p><a href="https://segmentfault.com/a/1190000002398039">更换博客系统——从jekyll到hexo</a></p></li><li><p><a href="https://github.com/iissnan/hexo-theme-next">hexo-theme-next主题</a></p></li><li><p><a href="https://github.com/litten/hexo-theme-yilia">hexo-theme-yilia主题</a></p></li></ul><h2 id="Liquid教程"><a href="#Liquid教程" class="headerlink" title="Liquid教程"></a><a href="http://blog.csdn.net/dont27/article/details/38097581">Liquid教程</a></h2>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
      <tag>jekyll</tag>
      
      <tag>octopress</tag>
      
      <tag>hexo</tag>
      
      <tag>blog</tag>
      
      <tag>liquid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS &amp; OS X 开发记事本</title>
    <link href="/2016/03/14/iOS%20&amp;%20OS%20X%20%E5%BC%80%E5%8F%91%E8%AE%B0%E4%BA%8B%E6%9C%AC/"/>
    <url>/2016/03/14/iOS%20&amp;%20OS%20X%20%E5%BC%80%E5%8F%91%E8%AE%B0%E4%BA%8B%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>开源库：</p><ul><li><p><a href="http://github.ibireme.com/github/list/ios">- ( ゜- ゜)つロ Github-iOS备忘</a>  好多开源代码推荐</p></li><li><p><a href="https://www.cocoacontrols.com/">cocoa controls</a>  有很多iOS，OS X，watchOS，tvOS相关的开源库视图总结。</p></li></ul><p>调试，debug：</p><ul><li><p><a href="http://www.jianshu.com/p/e89af3e9a8d7">Xcode watchpoint 调试方法</a>  强大的调试教程</p></li><li><p><a href="https://segmentfault.com/a/1190000000387082">Instruments工具</a>  Instruments教程</p></li><li><p><a href="https://zhuanlan.zhihu.com/p/19646016">Reveal查看任意app的高级技巧</a> 查看UI元素</p></li></ul><p>动画：</p><ul><li><p><a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS 保持界面流畅的技巧</a>  YYKit的作者所写，太凶残了!</p></li><li><p><a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques">iOS动画：iOS-Core-Animation-Advanced-Techniques</a>  iOS动画，很详细!</p></li><li><p><a href="https://github.com/sxyx2008/awesome-ios-animation">iOS动画库：awesome-ios-animation</a>  收集整理了下iOS平台下比较主流炫酷的几款动画框架</p></li></ul><p>swift：</p><ul><li><p><a href="http://www.cocoachina.com/special/swift/">从今天开始学习Swift</a>  swift教程</p></li><li><p><a href="https://github.com/ipader/SwiftGuide">SwiftGuide</a>  这份指南汇集了Swift语言主流学习资源，并以开发者的视角整理编排。</p></li><li><p><a href="https://github.com/numbbbbb/the-swift-programming-language-in-chinese">the-swift-programming-language-in-chinese</a>  中文版 Apple 官方 Swift 教程《The Swift Programming Language》</p></li></ul><p>UI：</p><ul><li><a href="https://github.com/sxyx2008/awesome-ios-chart">awesome-ios-chart</a>  表格开源库</li></ul><p>其他：</p><ul><li><p><a href="http://www.jianshu.com/p/b10680a32d35">证书问题</a>  又是讨厌的证书</p></li><li><p><a href="https://github.com/Aufree/trip-to-iOS">trip-to-iOS</a>  iOS学习资料整理，github上关注好高啊，还有一些名人博客！</p></li><li><p><a href="https://github.com/tiimgreen/github-cheat-sheet/blob/master/README.zh-cn.md">github秘籍</a>  秘籍秘籍秘籍!</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>记事本</tag>
      
      <tag>OS X</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发工具</title>
    <link href="/2016/03/14/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    <url>/2016/03/14/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="团队协作工具"><a href="#团队协作工具" class="headerlink" title="团队协作工具"></a>团队协作工具</h2><ul><li><strong>teambition</strong> 界面不错</li><li><strong>Tower.im</strong>小众，布丁后期用的工具</li><li><strong>Trello</strong>布丁前期用的工具</li></ul><h2 id="版本控制工具"><a href="#版本控制工具" class="headerlink" title="版本控制工具"></a>版本控制工具</h2><ul><li><strong>Github</strong>不解释</li><li><strong>SourceTree</strong>不错的git图形用户程序</li><li><strong>Gitlab</strong>Git服务</li></ul><h2 id="内测托管平台"><a href="#内测托管平台" class="headerlink" title="内测托管平台"></a>内测托管平台</h2><ul><li><strong>fir.im</strong>布丁，体验很好</li><li><strong>蒲公英</strong>功能更强大?</li></ul><h2 id="持续集成-CI"><a href="#持续集成-CI" class="headerlink" title="持续集成 CI"></a>持续集成 CI</h2><ul><li><strong>jenkins</strong>美承，<a href="http://www.jianshu.com/p/a501153c9d59">http://www.jianshu.com/p/a501153c9d59</a></li></ul><h2 id="交互设计"><a href="#交互设计" class="headerlink" title="交互设计"></a>交互设计</h2><ul><li><strong>flinto</strong>移动端定制</li><li><strong>sketch</strong>阿里设计师用的</li><li><strong>axure</strong>最流行，生成html格式数据</li></ul><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><ul><li><strong>Charles</strong>Mac抓包工具</li></ul><h2 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h2><ul><li><strong>Sublime Text</strong>太好用！</li><li><strong>TextMate</strong>一般</li></ul><h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><ul><li><strong>webstorm</strong>javascript IDE</li></ul>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS面试必备</title>
    <link href="/2015/11/28/iOS%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87/"/>
    <url>/2015/11/28/iOS%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h2 id="常用框架，iOS架构问题"><a href="#常用框架，iOS架构问题" class="headerlink" title="常用框架，iOS架构问题"></a><strong>常用框架，iOS架构问题</strong></h2><ul><li>AFNetworkinghttp请求</li><li>ReactiveCocoa响应式编程</li><li>MagicalRecor数据持久化</li><li>其他开源库的使用：CocoaPods，CocoaLumberjack，Masonry，TMCache，pop，SDWebImage，GPUImage，FLEX</li></ul><span id="more"></span><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a><strong>多线程</strong></h2><ul><li>GCD基于硬件的多核编程，抽象度低，接口简单，用于简单的多线程</li><li>NSOperation（任务） 与 NSOperationQueue（线程池）。NSOperation 重写main方法，两个衍生： NSInvocationOperation 和 NSBlockOperation。高度抽象，用于复杂的多线程</li><li>NSThread。通过初始化方法指定object和selector来执行。</li></ul><h2 id="iOS-delegate（委托，代理），protocol（协议）区别"><a href="#iOS-delegate（委托，代理），protocol（协议）区别" class="headerlink" title="iOS delegate（委托，代理），protocol（协议）区别"></a><strong>iOS delegate（委托，代理），protocol（协议）区别</strong></h2><p>Delegate ，又称为 委托或代理， 把一个类自己需要做的一部分事情，让另一个类（也可以就是自己本身）来完成，而实际做事的类为delegate</p><p>如：A对象持有B对象的弱引用，则B对象可以实现A对象的某些行为。A对象负责调用就可以。<br>类似于UITableView。</p><p>protocol主要目标是提供接口给遵守协议的类使用。类似于java的接口。</p><p>delegate通过protocol来实现</p><h2 id="iOS类别-Category-与类扩展-Extension"><a href="#iOS类别-Category-与类扩展-Extension" class="headerlink" title="iOS类别(Category)与类扩展(Extension)"></a><strong>iOS类别(Category)与类扩展(Extension)</strong></h2><ul><li>Category：不用继承对类添加方法 ， 不能添加变量</li><li>Extension：没有命名的类别Category。 放在.m文件中@implementation的上方。可添加方法和变量。 私有属性写到类扩展</li></ul><h2 id="retain，-assign，-copy，-weak-，strong，-block-weak等关键字意思"><a href="#retain，-assign，-copy，-weak-，strong，-block-weak等关键字意思" class="headerlink" title="retain， assign， copy， weak ，strong，__block,__weak等关键字意思"></a><strong>retain， assign， copy， weak ，strong，__block,__weak等关键字意思</strong></h2><ul><li>assign： 简单赋值，不更改索引计数</li><li>copy： 建立一个索引计数为1的对象，然后释放旧对象</li><li>retain：释放旧的对象，将旧对象的值赋予输入对象，再提高输入对象的索引计数为1</li><li>strong：强引用，引用计数+1。一旦最后一个strong型指针离去 ，这个对象将被释放，所有剩余的weak型指针都将被清除。</li><li>weak：弱引用，不更改引用计数</li><li>__block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型。</li><li>__weak只能在ARC模式下使用，也只能修饰对象（NSString），不能修饰基本数据类型（int）。</li><li>__block对象可以在block中被重新赋值，__weak不可以。</li><li>__weak 和assign 的区别在于，对象销毁 ，__weak置为nil，而assign为野指针，__weak更安全</li></ul><h2 id="iOS-layer"><a href="#iOS-layer" class="headerlink" title="iOS layer"></a><strong>iOS layer</strong></h2><p>CALayer(层)是屏幕上的一个矩形区域，在每一个UIView中都包含一个根CALayer，在UIView上的所有视觉效果都是在这个Layer上进行的。</p><p>他和UIView的区别是，只管绘制渲染。UIView是它的容器，UIView负责监听事件。 形象的比喻view是画板，layer是画布</p><h2 id="app生命周期"><a href="#app生命周期" class="headerlink" title="app生命周期"></a><strong>app生命周期</strong></h2><ul><li><p>willFinishLaunch     将要启动</p></li><li><p>didFinishLaunch     启动完成</p></li><li><p>DidBecomeActive     进入活动状态</p></li><li><p>WillResignActive     将要进入非活动状态，在此期间，应用程序不接收消息或事件，比如来电话了</p></li><li><p>DidEnterBackground     进入后台</p></li><li><p>WillEnterForeground     将要回到前台</p></li><li><p>WillTerminate     退出，销毁</p></li><li><p>启动程序</p><pre><code class="hljs">1.  willFinishLaunchingWithOptions</code></pre><ol start="2"><li>didFinishLaunchingWithOptions</li><li>applicationDidBecomeActive</li></ol></li><li><p>按下home键</p><pre><code class="hljs">1.  applicationWillResignActive</code></pre><ol start="2"><li>applicationDidEnterBackground</li></ol></li><li><p>双击home键，再打开程序</p><pre><code class="hljs">1.  applicationWillEnterForeground</code></pre><ol start="2"><li>applicationDidBecomeActive</li></ol></li></ul><h2 id="内存问题解决方案"><a href="#内存问题解决方案" class="headerlink" title="内存问题解决方案"></a><strong>内存问题解决方案</strong></h2><ul><li>analyze 静态编译分析</li><li>instruments 动态运行统计</li></ul><h2 id="线程间通信与进程间通信（IPC）"><a href="#线程间通信与进程间通信（IPC）" class="headerlink" title="线程间通信与进程间通信（IPC）"></a><strong>线程间通信与进程间通信（IPC）</strong></h2><ul><li>线程间通信：performSelector</li><li>进程间通信： URL Schema就是iOS内的应用调用协议，应用A可以声明自定义的调用协议，就如http&#x2F;https那样，当另一个应用B打算在应用内打开应用A时，可以打开使用A自定义的协议开头的URL来打开A，除了协议头，URL中还可以附加其他参数</li></ul><h2 id="runtime概念"><a href="#runtime概念" class="headerlink" title="runtime概念"></a><strong>runtime概念</strong></h2><p>object-c的动态性，运行时修改对象的方法和特性。原理是oc的消息机制</p><h2 id="runloop概念"><a href="#runloop概念" class="headerlink" title="runloop概念"></a><strong>runloop概念</strong></h2><p>特殊的一个无限循环的线程， 它管理了其需要处理的事件和消息。</p><h2 id="block，闭包的概念"><a href="#block，闭包的概念" class="headerlink" title="block，闭包的概念"></a><strong>block，闭包的概念</strong></h2><p>Block是对C语言的扩展，用来实现匿名函数的特性。相当于JavaScript的闭包。是一种代码块，将一段代码看做一个对象</p><p>闭包就是能够读取其它函数内部变量的函数</p><h2 id="viewcontroller-生命周期"><a href="#viewcontroller-生命周期" class="headerlink" title="viewcontroller 生命周期"></a><strong>viewcontroller 生命周期</strong></h2><ul><li>viewDidLoad     视图加载完成</li><li>viewWillAppear     视图即将可见</li><li>viewDidAppear     视图可见</li><li>viewWillDisappear     视图即将消失</li><li>viewDidDisappear     视图消失</li></ul><h2 id="frame和-bounds-的-区别"><a href="#frame和-bounds-的-区别" class="headerlink" title="frame和 bounds 的 区别"></a><strong>frame和 bounds 的 区别</strong></h2><ul><li>frame：描述当前视图在其父视图中的位置和大小。</li><li>bounds：描述当前视图在其自身坐标系统中的位置和大小。</li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h2><ul><li>array（NSArray ）：数组集合</li><li>dictionary（NSDictionary）：键值对</li><li>set（ NSSet） ：无序列表</li><li>衍生的数据结构：可变array（ NSMutableArray），可变dictionary（ NSMutableDictionary）</li></ul><h2 id="iOS内存异常，野指针"><a href="#iOS内存异常，野指针" class="headerlink" title="iOS内存异常，野指针"></a><strong>iOS内存异常，野指针</strong></h2><p>对已经释放的对象进行操作会出现野指针，导致系统崩溃。xcode无法确定异常的代码位置。需要设置xcode，使得变量推迟释放，当出现野指针，会打印出log提示</p><h2 id="id和NSObject的区别"><a href="#id和NSObject的区别" class="headerlink" title="id和NSObject的区别"></a><strong>id和NSObject的区别</strong></h2><p>两个类型都含有Class isa，但NSObject同时包含了一些其它的方法，并需要实现NSObject协议。<br>所以NSObject<em>可以用id来表示。但id不能用NSObject</em>来表示。</p><p>id就是一个指针，它可以指向的类型不仅限于NSObject。</p><p>NSObject*就是 NSObject类型的指针了，它范围较小。</p><p>id<nsobject>是指针，它要求它指向的类型要实现NSObject protocol。</nsobject></p><h2 id="nil、Nil、NULL、NSNull的区别"><a href="#nil、Nil、NULL、NSNull的区别" class="headerlink" title="nil、Nil、NULL、NSNull的区别"></a><strong>nil、Nil、NULL、NSNull的区别</strong></h2><ul><li>nil：指向一个对象的空指针</li><li>Nil：指向一个类的空指针</li><li>NULL：指向其他类型（如：基本类型、C类型）的空指针</li><li>NSNull：通常表示集合中的空值</li></ul><h2 id="NSString什么时候用copy，什么时候用strong"><a href="#NSString什么时候用copy，什么时候用strong" class="headerlink" title="NSString什么时候用copy，什么时候用strong"></a><strong>NSString什么时候用copy，什么时候用strong</strong></h2><p>对源头是NSMutableString的字符串，retain仅仅是指针引用，增加了引用计数器，这样源头改变的时候，用这种retain方式声明的变量（无论被赋值的变量是可变的还是不可变的），它也会跟着改变;而copy声明的变量，它不会跟着源头改变，它实际上是深拷贝。</p><p>对源头是NSString的字符串，无论是retain声明的变量还是copy声明的变量，当第二次源头的字符串重新指向其它的地方的时候，它还是指向原来的最初的那个位置，也就是说其实二者都是指针引用，也就是浅拷贝。</p><p>大部分的时候NSString的属性都是copy</p><h2 id="响应者链-Responder-Chain"><a href="#响应者链-Responder-Chain" class="headerlink" title="响应者链(Responder Chain)"></a><strong>响应者链(Responder Chain)</strong></h2><p>UIWindow实例对象会首先在它的内容视图上调用hitTest:withEvent:，此方法会在其视图层级结构中的每个视图上调用pointInside:withEvent:（该方法用来判断点击事件发生的位置是否处于当前视图范围内，以确定用户是不是点击了当前视图），如果pointInside:withEvent:返回YES，则继续逐级调用，直到找到touch操作发生的位置，这个视图也就是要找的hit-test view。</p><p>hitTest:withEvent:方法的处理流程如下:</p><ol><li>首先调用当前视图的pointInside:withEvent:方法判断触摸点是否在当前视图内；</li><li>若返回NO,则hitTest:withEvent:返回nil;</li><li>若返回YES,则向当前视图的所有子视图(subviews)发送hitTest:withEvent:消息，所有子视图的遍历顺序是从最顶层视图一直到到最底层视图，即从subviews数组的末尾向前遍历，直到有子视图返回非空对象或者全部子视图遍历完毕；</li><li>若第一次有子视图返回非空对象，则hitTest:withEvent:方法返回此对象，处理结束；</li><li>如所有子视图都返回非，则hitTest:withEvent:方法返回自身(self)。</li></ol><p>具体教程：<a href="http://www.cnblogs.com/snake-hand/p/3178070.html">http://www.cnblogs.com/snake-hand/p/3178070.html</a></p><h2 id="arc原理"><a href="#arc原理" class="headerlink" title="arc原理"></a><strong>arc原理</strong></h2><p>编译环境 自动在代码中加入了retain&#x2F;release。</p><h2 id="NSProxy概念"><a href="#NSProxy概念" class="headerlink" title="NSProxy概念"></a><strong>NSProxy概念</strong></h2><p>Objective-C不支持多重继承，但是我们可以使用NSProxy的消息转发机制，来转发可由其它类的对象处理的任务，达成同样的目的。它是object-c实现代理模式的途径。AOP面向切面编程的解决方案。</p><h2 id="aop概念"><a href="#aop概念" class="headerlink" title="aop概念"></a><strong>aop概念</strong></h2><p>面向切面编程，类似于ssh中的拦截器。降低了代码的耦合。</p><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a><strong>开发工具</strong></h2><ul><li>gitlab                    git协作开发平台</li><li>sourceTree            git图形用户界面</li><li>teambition            团队协作工具</li></ul><h2 id="tcp-x2F-ip和socket"><a href="#tcp-x2F-ip和socket" class="headerlink" title="tcp&#x2F;ip和socket"></a><strong>tcp&#x2F;ip和socket</strong></h2><ul><li>socket为底层套接字（数据链路层）</li><li>ip是一种网络地址（网络层）</li><li>tcp是基于ip的可靠地链接（运输层）</li><li>udp是基于ip的快速不可靠连接（运输层）</li></ul><h2 id="rest-api"><a href="#rest-api" class="headerlink" title="rest api"></a><strong>rest api</strong></h2><p>get put post delete。</p><ul><li>GET用来获取资源</li><li>POST用来新建资源（也可以用于更新资源）</li><li>PUT用来更新资源</li><li>DELETE用来删除资源</li></ul><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a><strong>开发流程</strong></h2><p>需求分析，架构设计，编码，测试，维护</p><h2 id="你需要问面试官的问题"><a href="#你需要问面试官的问题" class="headerlink" title="你需要问面试官的问题"></a><strong>你需要问面试官的问题</strong></h2><ul><li>公司iOS人员架构</li><li>公司文化，加班文化</li><li>此次面试不足</li><li>薪水，其他福利，五险一金怎么缴纳</li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
